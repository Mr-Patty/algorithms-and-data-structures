/*
Зелье
Злой маг Крокобобр варит зелье. У него есть большая колба, которую можно ставить на огонь и две колбы поменьше, которые огня не выдержат. В большой колбе до самого верха налиты слёзы дракона, которые нужно подогреть на огне и затем смешать с другими компонентами. Маленькие колбы пусты. Ёмкости всех колб магу Крокобобру известны — N лигул в большой колбе, в маленьких — по M и K лигул. Жидкости можно переливать из любой колбы в любую, если выполняется одно из условий: после переливания либо одна из колб становится пустой, либо одна из колб становится полной, частичные переливания недопустимы. Слёзы дракона достались Крокобобру очень дорого, поэтому их нельзя выливать в другие сосуды.

По рецепту в большой колбе нужно подогреть ровно L лигул слёз дракона. Помогите Крокобобру определить, сколько переливаний он должен сделать для этого.

Input format
N M K L

1⩽N,M,K,L⩽2000

N>M, N>K; N>L

Output format
Минимально необходимое число переливаний или слово OOPS, если задача неразрешима.

Examples
Input
10 6 5 8

Output
7

Notes
Для приведённых в примере данных возможна следующая последовательность переливаний:
10 0 0

4 6 0

4 1 5

9 1 0

9 0 1

3 6 1

3 2 5

8 2 0
*/
#include <iostream>
#include <string>
#include <vector>
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <cmath>
#include <iomanip>

using namespace std;

void func(vector<vector<int> > &graph, int i, int j, int n, int m, int k, int l) {
    if (l == n - i -j)
        return;
    if (graph[i][k - 1] != -1) {
        if (graph[i][k - 1] > graph[i][j]) {
            graph[i][k - 1] = graph[i][j] + 1;
            func(graph, i, k - 1, n, m, k, l);
        }
    } else {
        graph[i][k - 1] = graph[i][j] + 1;
    }
    if (graph[m - 1][j] != -1) {

    }
}

int main() {
    std::ios_base::sync_with_stdio(false);
    int n, m, k, l;
    cin >> n >> m >> k >> l;
    vector<vector<int> > graph(m, vector<int>(k, -1));
    if (l > n || (n - l > m + k)) {
        cout << "OOPS" << endl;
        return 0;
    }

    return 0;
}
